顶点和边的类型
顶点和边有不同的类型，这要看我们想求解什么问题。
由于我们是3D的slam，所以顶点取成了相机姿态：g2o::VertexSE3，
而边则是连接两个VertexSE3的边：g2o::EdgeSE3。如果你想用别的类型的顶点（如2Dslam，路标点），
你可以看看/usr/local/include/g2o/types/下的文件，基本上涵盖了各种slam的应用，应该能满足你的需求。

SE3是4×4的变换矩阵啦，也就是这里用的相机姿态了。
更深层的解释需要李代数里的知识。相应的，2D slam就要用SE2作为姿态节点了。在我们引用<g2o/types/slam3d/types_slam3d.h>时，就已经把相关的点和边都包含进来了

优化方法
g2o允许你使用不同的优化求解器（然而实际效果似乎差别不大）。你可以选用csparse, pcg, cholmod等等。
这里使用csparse为例。

.g2o文件前面是顶点的定义，包含 ID, x,y,z,qx,qy,qz,qw。后边则是边的定义：ID1, ID2, dx, T 以及信息阵的上半角。







1. 关键帧的提取。把每一帧都拼到地图是去是不明智的。因为帧与帧之间距离很近，导致地图需要频繁更新，浪费时间与空间。所以，我们希望，当机器人的运动超过一定间隔，就增加一个“关键帧”。最后只需把关键帧拼到地图里就行了。
2. 回环的检测。回环的本质是识别曾经到过的地方。最简单的回环检测策略，就是把新来的关键帧与之前所有的关键帧进行比较，不过这样会导致越往后，需要比较的帧越多。所以，稍微快速一点的方法是在过去的帧里随机挑选一些，与之进行比较。更进一步的，也可以用图像处理/模式识别的方法计算图像间的相似性，对相似的图像进行检测。

把这两者合在一起，就得到了我们slam程序的基本流程。以下为伪码：
1. 初始化关键帧序列：F ，并将第一帧f0放入F。
2. 对于新来的一帧I，计算F中最后一帧与I的运动，并估计该运动的大小e。有以下几种可能性：
	若e>Eerror，说明运动太大，可能是计算错误，丢弃该帧；
	若没有匹配上（match太少），说明该帧图像质量不高，丢弃； 
	若e<Ekey，说明离前一个关键帧很近，同样丢弃；
	剩下的情况，只有是特征匹配成功，运动估计正确，同时又离上一个关键帧有一定距离，则把I作为新的关键帧，进入回环检测程序：

3. 近距离回环：匹配I与F末尾m个关键帧。匹配成功时，在图里增加一条边。
4. 随机回环：随机在F里取n个帧，与I进行匹配。若匹配上，在图里增加一条边。
5. 将I放入F末尾。若有新的数据，则回2； 若无，则进行优化与地图拼接。
大体上如此，也可以作一些更改。例如在线跑的话呢，可以定时进行一次优化与拼图。或者，在成功检测到回环时，同时检测这两个帧附近的帧，那样得到的边就更多啦。再有呢，如果要做实用的程序，还要考虑机器人如何运动，如果跟丢了怎么进行恢复等一些实际的问题呢。

